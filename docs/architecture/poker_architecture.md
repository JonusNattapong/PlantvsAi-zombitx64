# สถาปัตยกรรมของเกมโป๊กเกอร์

เอกสารนี้อธิบายสถาปัตยกรรมและการออกแบบระบบของเกมโป๊กเกอร์ใน Tictactoe-zombitx64

## ภาพรวมของสถาปัตยกรรม

เกมโป๊กเกอร์ถูกพัฒนาด้วยสถาปัตยกรรมแบบ client-server โดยใช้:

1. **Frontend**: HTML, CSS, JavaScript
2. **Backend**: Flask (Python)
3. **การสื่อสาร**: RESTful API
4. **AI**: โมเดลแบบ ZomPokerX64 และ rule-based fallback

```
                    +---------------------+
                    |       Client        |
                    | (HTML, CSS, JS)     |
                    +----------+----------+
                               |
                               | HTTP/AJAX
                               |
                    +----------v----------+
                    |  Flask Web Server   |
                    +----------+----------+
                               |
             +----------------++----------------+
             |                 |                 |
+------------v--------+ +------v------+ +-------v----------+
| Game Logic (Python) | |   AI Logic  | | Session Management|
+---------------------+ +------+------+ +------------------+
                               |
                      +--------v--------+
                      | ZomPokerX64 AI  |
                      | (Neural Network)|
                      +-----------------+
```

## โครงสร้างโค้ด

โค้ดของเกมโป๊กเกอร์ถูกแบ่งออกเป็นส่วนต่าง ๆ ดังนี้:

### Backend (Python)

- **app.py**: ตัวควบคุมหลักของเว็บเซิร์ฟเวอร์ Flask และตัวจัดการ routes
- **poker_game.py**: คลาสและฟังก์ชันที่จัดการตรรกะของเกมโป๊กเกอร์
- **card.py**: คลาสสำหรับไพ่และการคำนวณมือที่ชนะ
- **player.py**: คลาสสำหรับจัดการข้อมูลผู้เล่น
- **zompokerx64.py**: โมเดล AI ขั้นสูงสำหรับเกมโป๊กเกอร์
- **simple_ai.py**: โมเดล AI พื้นฐานที่ใช้เป็น fallback

### Frontend

- **poker.html**: เทมเพลต HTML สำหรับหน้าเกมโป๊กเกอร์
- **static/css/poker.css**: สไตล์ชีทสำหรับเกมโป๊กเกอร์
- **static/js/poker.js**: โค้ด JavaScript สำหรับการดำเนินการของเกมฝั่งไคลเอนต์
- **static/sounds/**: ไฟล์เสียงสำหรับเกมโป๊กเกอร์
- **static/images/cards/**: ภาพไพ่ SVG

## การทำงานของระบบ

### การทำงานพื้นฐาน

1. **การเริ่มเกม**:
   - ผู้เล่นเข้าหน้าเว็บเกมโป๊กเกอร์
   - เว็บเซิร์ฟเวอร์สร้าง session ID และส่งหน้า HTML กลับไป
   - เซิร์ฟเวอร์สร้างเกมใหม่เป็น Python object ในหน่วยความจำ

2. **การดำเนินเกม**:
   - ผู้เล่นทำการเลือกการกระทำ (check, call, raise, fold)
   - ฝั่งไคลเอนต์ส่งการกระทำไปยังเซิร์ฟเวอร์ผ่าน RESTful API
   - เซิร์ฟเวอร์ประมวลผลการกระทำและอัปเดตสถานะเกม
   - ถ้าเป็นตาของ AI เซิร์ฟเวอร์จะเรียกใช้โมเดล AI เพื่อกำหนดการกระทำ
   - เซิร์ฟเวอร์ส่งสถานะเกมที่อัปเดตแล้วกลับไปยังไคลเอนต์

3. **การแสดงผล**:
   - ไคลเอนต์รับสถานะเกมและอัปเดต UI
   - การเปลี่ยนแปลงจะแสดงด้วยภาพและเสียงเพื่อประสบการณ์ที่สมจริง

## สถาปัตยกรรม AI

เกมโป๊กเกอร์ใช้ระบบ AI ที่มีสองส่วน:

### 1. โมเดล ZomPokerX64 (โมเดลขั้นสูง)

ZomPokerX64 เป็นโมเดล AI ที่ใช้ Machine Learning และ Neural Networks เพื่อตัดสินใจในเกมโป๊กเกอร์ โดยมีโครงสร้างดังนี้:

```
Input Features -> Preprocessing -> Neural Network -> Decision Engine -> Action
      ^                                                    |
      |                                                    v
Opponent Model <- - - - - - - - - - - - - Monte Carlo Simulation
```

**คุณสมบัติ**:
- **Pre-calculated hand strength tables**: ตารางความแข็งแกร่งของไพ่ที่คำนวณไว้ล่วงหน้า
- **Neural network architecture**: เครือข่ายประสาทเทียมที่มี 3 hidden layers
- **Opponent modeling**: การวิเคราะห์รูปแบบการเล่นของคู่ต่อสู้
- **Monte Carlo simulations**: การจำลองเกมหลายครั้งเพื่อคำนวณโอกาสชนะ
- **Adaptive betting patterns**: การปรับรูปแบบการเดิมพันตามสถานการณ์

### 2. Simple AI (โมเดล Fallback)

โมเดล AI พื้นฐานที่ใช้เมื่อโมเดล ZomPokerX64 ไม่พร้อมใช้งาน:

- **Rule-based decisions**: การตัดสินใจตามกฎที่กำหนดไว้ล่วงหน้า
- **Hand strength calculation**: การคำนวณความแข็งแกร่งของไพ่อย่างง่าย
- **Pot odds consideration**: การพิจารณาอัตราต่อรองของหม้อ
- **Position-based strategy**: กลยุทธ์ที่ขึ้นอยู่กับตำแหน่งบนโต๊ะ

## การจัดการข้อมูล

### การเก็บข้อมูลเกม

ข้อมูลเกมถูกเก็บในแบบที่แตกต่างกันตามระยะเวลา:

1. **ช่วงเกม (In-Game)**:
   - เก็บในหน่วยความจำเป็น Python objects
   - ใช้ session ID เป็นคีย์เพื่อเชื่อมโยงกับเซสชันของผู้เล่น

2. **ข้อมูลระยะยาว (Long-term)**:
   - สถิติการเล่นเก็บในไฟล์บนเซิร์ฟเวอร์
   - ข้อมูลการฝึกโมเดล AI เก็บในรูปแบบของโมเดล Machine Learning

### การจัดการเซสชัน

- ใช้ Flask Session เพื่อจัดการเซสชันของผู้ใช้
- ใช้ Dictionary หรือ Redis (ในการใช้งานจริง) เพื่อเก็บข้อมูลเกม
- มีการทำความสะอาดเซสชันที่ไม่ได้ใช้งานเป็นเวลานาน

## แนวทางการทดสอบ

สำหรับการทดสอบเกมโป๊กเกอร์ เราใช้วิธีการดังนี้:

1. **Unit Testing**:
   - ทดสอบคลาสและฟังก์ชันแต่ละส่วนแยกกัน
   - ใช้ pytest สำหรับการเขียนและรันเทสต์

2. **Integration Testing**:
   - ทดสอบการทำงานร่วมกันของส่วนต่าง ๆ
   - ทดสอบการสื่อสารระหว่าง frontend และ backend

3. **AI Testing**:
   - ประเมินการตัดสินใจของ AI ในสถานการณ์ต่าง ๆ
   - เปรียบเทียบประสิทธิภาพกับโมเดลเก่า

## ข้อควรระวังและข้อจำกัด

1. **Performance Considerations**:
   - การคำนวณ Monte Carlo simulations อาจใช้ทรัพยากรมาก
   - โมเดล Neural Network ต้องการ GPU สำหรับประสิทธิภาพที่ดี

2. **Scalability**:
   - การเก็บเกมในหน่วยความจำมีข้อจำกัดเมื่อมีผู้เล่นจำนวนมาก
   - ควรพิจารณาใช้ Redis หรือฐานข้อมูลสำหรับการใช้งานจริง

3. **Security**:
   - ตรวจสอบการส่งข้อมูลจากผู้เล่นเพื่อป้องกัน cheating
   - ป้องกันการเข้าถึงเกมของผู้อื่นผ่าน session ID 